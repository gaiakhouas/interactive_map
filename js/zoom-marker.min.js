(function($) {

    const GLOBAL = []; // Collection of global variable
    var gIndex = 0;
    const MAX_IMG_Z_INDEX = 980; // Image max z-index
    const CANVAS_SUFFIX = "_canvas"; // canvas Layer suffix

    $.fn.extend({
        "zoomMarker": function(_options) {
            const ID = $(this).attr('id');
            initGlobalData(ID);
            const params = getGlobalParam(ID);
            var options = params.options;
            var that = params.that;
            var dialog = params.dialog;
            var isInit = params.isInit;

            if (isInit)
                return;
            isInit = true;
            params.isInit = isInit;
            document.ondragstart = function() {
                return false;
            };
            that = $(this);
            params.that = that;
            var offset;
            // Initial configuration 
            if (typeof(_options) === 'undefined')
                options = defaults;
            else
                options = $.extend({}, defaults, _options);
            params.options = options;
            // Configure image resources
            if (options.src === null) {
                console.error('Image resources is not defined.');
                return;
            } else {
                loadImage(ID, options.src);
            }
            // Initialize the mouse scroll listener
            that.bind('mousewheel', function(event, delta) {
                that.zoomMarker_Zoom(options.zoom_lock ? null : {
                    x: event.pageX,
                    y: event.pageY
                }, delta > 0 ? (1 + options.rate) : (1 - options.rate));
                return false;
            });
            // Picture drag listener
            const picHammer = new Hammer(document.getElementById($(this).attr('id')));
            picHammer.get('pan').set({
                direction: Hammer.DIRECTION_ALL
            });
            picHammer.on("panleft panright panup pandown", function(e) {
                if (!(options.pinchlock || false)) {
                    dialog.hide();
                    that.zoomMarker_Move(e.deltaX + offset.left, e.deltaY + offset.top);
                    // Move layer order
                    if (options.auto_index_z) {
                        moveImageTop(ID);
                    }
                }
            });
            picHammer.on("panstart", function() {
                offset = that.offset();
            });
            picHammer.on("panend", function() {
                // Move layer order pan
                options.pinchlock = false;
            });
            // Touch screen movement event
            picHammer.get('pinch').set({
                enable: true
            });
            picHammer.on("pinchmove", function(e) {
                dialog.hide();
                that.zoomMarker_Zoom({
                    x: e.center.x,
                    y: e.center.y
                }, e.scale / options.pinchscale);
                options.pinchscale = e.scale;
            });
            picHammer.on("pinchstart", function() {
                // In order to prevent the inconsistency of the lifting speeds of the two fingers after the zoom gesture is over, the misjudgment of the pan event is caused, the pinch is locked and released after the pan is released 
                options.pinchlock = true;
                options.pinchscale = 1.0;
            });
            // Add a div tag for displaying the floating content window of the marker
            dialog = $("<div id='zoom-marker-hover-dialog' class='zoom-marker-hover-dialog'></div>");
            params.dialog = dialog;
            that.parent().append(dialog);
            // Add image click listener, send message
            picHammer.on('tap', function(e) {
                const params = getGlobalParam(ID);
                const options = params.options;
                const that = params.that;
                // Only when the image is at the top, will it respond to the click event
                if (!isLayoutOnTop(ID)) {
                    moveImageTop(ID);
                    return;
                }
                // Send a message
                if (typeof(e.pointers[0].x) === 'undefined') {
                    const offset = that.offset();
                    that.trigger("zoom_marker_mouse_click", {
                        x: (e.center.x - offset.left) / that.width() * options.imgNaturalSize.width,
                        y: (e.center.y - offset.top) / that.height() * options.imgNaturalSize.height
                    });
                } else {
                    that.trigger("zoom_marker_mouse_click", {
                        pageX: e.pointers[0].offsetX,
                        pageY: e.pointers[0].offsetY,
                        x: e.pointers[0].offsetX / that.width() * options.imgNaturalSize.width,
                        y: e.pointers[0].offsetY / that.height() * options.imgNaturalSize.height
                    });
                }
                // Move layer order
                if (options.auto_index_z) {
                    moveImageTop(ID);
                }
            });
        },
        // Load picture
        "zoomMarker_LoadImage": function(src) {
            const ID = $(this).attr('id');
            loadImage(ID, src, true);
        },
        // for changing the image color on click
        "zoomMarker_ChangeMarkerImageClick": function(id) {
            $('#viewArea' + id).children().first().addClass('selected')
            $('#viewArea' + id).children().first().attr("src", "img/Map_poi-selected.png");
            $('#viewArea' + id).css("z-index", "982");
            $('#viewArea' + id).children().first().attr("z-index", "982");
            $('#defaultContent').addClass('d-none');

            //alert($('.selected').length);
            for(let i=0; i<= $('.zoom-marker').length; i++){
                if(id != i){
                    // update of precedent selected markers
                    $('#viewArea' + i).children().first().removeClass('selected');
                    $('#viewArea' + i).children().first().attr("src", "img/Map_poi-default.png");
                    //console.log(`zoom marker : ${i} `)
                }
            }
        },
        // for changing the image color on blur
        "zoomMarker_ChangeMarkerImageBlur": function(id) {
            $('#viewArea').click(function() {
                $('#viewArea' + id).children().first().removeClass('selected');
                $('#viewArea' + id).children().first().attr("src", "img/Map_poi-default.png");
                $('#content').addClass('d-none');
                $('#defaultContent').removeClass('d-none');
            });
        },
        // for changing the image color on click and on blur
        "zoomMarker_ChangeMarkerImage": function(id) {
            $('#viewArea').zoomMarker_ChangeMarkerImageClick(id);
            $('#viewArea').zoomMarker_ChangeMarkerImageBlur(id);
            // get content function

        },
        "zoomMarker_getContent": function(obj) {
            $('#contactName').html(obj.location);
        },
        /**
         * Picture zoom
         * @param center    Zoom center coordinates,{x:1, y:2}
         * @param scale     Zoom ratio, >0 means zoom in, <0 means zoom out
         */
        "zoomMarker_Zoom": function(center, scale) {
            const ID = $(this).attr('id');
            const params = getGlobalParam(ID);
            const options = params.options;
            const that = params.that;

            //var that = $(this);
            //var options = document.options;
            const offset = that.offset();
            const hwRatio = options.imgNaturalSize.height / options.imgNaturalSize.width;
            const h0 = that.height();
            const w0 = that.width();
            var tarWidth = w0 * scale;
            var tarHeight = tarWidth * hwRatio;
            // Maximum width limit
            if (null != options.max && tarWidth > options.max) {
                tarWidth = options.max;
                tarHeight = tarWidth * hwRatio;
            }
            // Minimum width limit
            else if (null != options.min && tarWidth < options.min) {
                tarWidth = options.min;
                tarHeight = tarWidth * hwRatio;
            }

            tarWidth = parseInt(tarWidth);
            tarHeight = parseInt(tarHeight);

            if (typeof(center) === 'undefined' || center === null) {
                center = {};
                center.x = offset.left + w0 / 2;
                center.y = offset.top + h0 / 2;
            }
            var y = center.y - tarHeight * (center.y - offset.top) / h0;
            var x = center.x - tarWidth * (center.x - offset.left) / w0;

            var isOverlap = false;
            if (options.move_limit) {
                var param = limitLockZoom($(this), tarWidth, tarHeight, x, y, center);
                if (param.isTerminate) {
                    return;
                }
                isOverlap = param.isOverlap;
                if (isOverlap) {
                    // Out-of-bounds operation
                    that.height(param.height);
                    that.width(param.width);
                    that.offset({
                        top: param.offset.top,
                        left: param.offset.left
                    });
                }
            }
            // No out of bounds after zooming
            if (!isOverlap) {
                that.height(tarHeight);
                that.width(tarWidth);
                that.offset({
                    top: y,
                    left: x
                });
            }
            reloadMarkers(ID);
            resizeCanvas(ID);
        },
        // Picture drag
        // x>0 Move right, y>0 move down
        "zoomMarker_Move": function(x, y) {
            const ID = $(this).attr('id');
            const params = getGlobalParam(ID);
            const options = params.options;
            // Whether to allow drag
            if (options.enable_drag) {
                // Whether to lock
                if (options.move_limit) {
                    limitLockOffset($(this), x, y);
                } else {
                    $(this).offset({
                        top: y,
                        left: x
                    });
                }
                reloadMarkers(ID);
                resizeCanvas(ID);
            }
        },
        // Add marker
        // marker {src:"marker.png", x:100, y:100, size:20}
        "zoomMarker_AddMarker": function(marker) {
            return addMarker($(this).attr('id'), marker);
        },
        // Delete marker
        "zoomMarker_RemoveMarker": function(markerId) {
            removeMarker($(this).attr('id'), markerId);
        },
        // Clear marker
        "zoomMarker_CleanMarker": function() {
            cleanMarkers($(this).attr('id'));
        },
        // Get the real size of the image
        "zoomMarker_GetPicSize": function() {
            const ID = $(this).attr('id');
            const params = getGlobalParam(ID);
            const options = params.options;
            return options.imgNaturalSize;
        },
        // Set whether to allow dragging
        "zoomMarker_EnableDrag": function(enable) {
            enableDrag($(this).attr('id'), enable);
        },
        // Top image iteration order
        "zoomMarker_TopIndexZ": function() {
            moveImageTop($(this).attr('id'));
        },
        // Get canvas drawing layer context
        "zoomMarker_Canvas": function() {
            const ID = $(this).attr('id');
            const params = getGlobalParam(ID);
            return params.canvas.context;
        },
        // Empty the canvas
        "zoomMarker_CanvasClean": function() {
            const ID = $(this).attr('id');
            addCanvas(ID);
        },
        // Move the marker
        "zoomMarker_MoveMarker": function(markerId, x, y) {
            const ID = $(this).attr('id');
            const params = getGlobalParam(ID);
            $(params.markerList).each(function(index, marker) {
                if (marker.id === markerId) {
                    setMarkerOffset(ID, marker.marker, {
                        x: x,
                        y: y,
                        size: marker.param.size
                    }, params.that.offset());
                    return false;
                }
            });
        },
        // Restore the original size of the image after loading
        "zoomMarker_ResetImage": function() {
            const ID = $(this).attr('id');
            const params = getGlobalParam(ID);
            const initSize = params.initSize;
            console.log(params.options.markers);
            params.that.width(initSize.width).height(initSize.height).offset({
                top: initSize.top,
                left: initSize.left
            });
            reloadMarkers(ID);
            resizeCanvas(ID);
        },
        // Refresh all marker points of the current image
        "zoomMarker_ReloadMarkers": function() {
            const ID = $(this).attr('id');
            reloadMarkers(ID);
        },
    });

    /**
     * Initialize global variables
     * @param id        The ID of the current item, as the unique KEY for identification
     */
    const initGlobalData = function(id) {
        if (typeof(GLOBAL[id]) === 'undefined') {
            const param = {
                index: gIndex += 2,
                id: id,
                options: {
                    imgNaturalSize: {
                        width: 0,
                        height: 0
                    } // Real image size
                },
                initSize: {
                    width: 0,
                    height: 0,
                    top: 0,
                    left: 0
                }, // Initial size and position
                that: null,
                dialog: null,
                isInit: false,
                markerList: [], // Array, store the DOM object of the marker
                markerId: 0, // The unique ID of the marker, which can only be increased
                canvas: {
                    item: null,
                    context: null
                } // canvas drawing layer
            };
            GLOBAL.push(param);
            return param;
        } else {
            return GLOBAL[id];
        }
    };

    /**
     * Get global variable attribute value
     * @param id            item corresponding ID
     * @returns {*}
     */
    const getGlobalParam = function(id) {
        for (var i = 0; i < GLOBAL.length; ++i) {
            if (GLOBAL[i].id === id) {
                return GLOBAL[i];
            }
        }
        return null;
    };

    /**
     * Get the picture size asynchronously, you need to wait for the picture to load before you can judge the actual size of the picture
     * @param img
     * @param fn        {width:rw, height:rh}
     */
    const getImageSize = function(img, fn) {
        img.onload = null;
        // IE compatibility issues
        /*if(img.complete){
         fn(_getImageSize(img));
         }
         else{
         img.onload = function(){
         fn(_getImageSize(img));
         }
         }*/
        img.onload = function() {
            fn(_getImageSize(img));
        }
    };

    /**
     * The sub-method to get the image size, refer to getImageSize()
     * @param img
     * @returns {{width: (Number|number), height: (Number|number)}}
     * @private
     */
    const _getImageSize = function(img) {
        var rw, rh;
        if (typeof img.naturalWidth === "undefined") {
            // IE 6/7/8
            const i = new Image();
            i.src = img.src;
            rw = i.width;
            rh = i.height;
        } else {
            // HTML5 browsers
            rw = img.naturalWidth;
            rh = img.naturalHeight;
        }
        return ({
            width: rw,
            height: rh
        });
    };

    /**
     * Load picture
     * @param id        The id corresponding to the item that called the method
     * @param src       Load image resource path
     * @param noResize  Whether to adjust the position of the picture
     */
    const loadImage = function(id, src, noResize) {
        const params = getGlobalParam(id);
        const options = params.options;
        const that = params.that;
        that.trigger("zoom_marker_img_load", src);
        that.attr("src", src);
        that.css("z-index", params.index);
        getImageSize(document.getElementsByName(that.attr('name'))[0], function(size) {
            if (typeof(noResize) === 'undefined' || !noResize) {
                // Adjust picture width and height
                const originWidth = that.width();
                const originHeight = that.height();
                if (options.width != null) {
                    that.width(options.width);
                    that.height(that.width() / originWidth * originHeight);
                }
            }
            // Configure image size
            options.imgNaturalSize = size;
            params.options.imgNaturalSize = size;
            // Image centered display
            if (typeof(noResize) === 'undefined' || !noResize) {
                imageCenterAlign(id);
            }
            // Configure initial size
            params.initSize.width = that.width();
            params.initSize.height = that.height();
            params.initSize.left = that.offset().left;
            params.initSize.top = that.offset().top;
            // After the image size is loaded successfully, configure the marker
            loadMarkers(id, options.markers);
            // 图层置顶
            moveImageTop(id);
            // Whether to add canvas overlay
            if (options.enable_canvas) {
                addCanvas(id);
            }
            // Broadcast message
            that.trigger("zoom_marker_img_loaded", size);
        });
    };

    /**
     * Image centered
     * @param id    the id corresponding to the item
     */
    const imageCenterAlign = function(id) {
        const params = getGlobalParam(id);
        const that = params.that;
        // Image centered v
        const offset = that.offset();
        const pDiv = that.parent();
        const top = offset.top + (pDiv.height() - that.height()) / 2;
        const left = offset.left + (pDiv.width() - that.width()) / 2;
        that.offset({
            top: top > 0 ? top : 0,
            left: left > 0 ? left : 0
        });
    };

    /**
     * Load marker
     * @param id        the id corresponding to the item
     * @param markers   The array of markers that need to be added
     */
    const loadMarkers = function(id, markers) {
        $(markers).each(function(index, marker) {
            addMarker(id, marker);
        });
    };

    /**
     * Add marker
     * @param id  the id corresponding to the item
     * @param marker
     */
    const addMarker = function(id, marker) {
        const params = getGlobalParam(id);
        const options = params.options;
        const dialog = params.dialog;
        const that = params.that;
        const markerId = params.markerId;
        const markerList = params.markerList;
        const _marker = $("<div id='" + id + markerId + "' class='zoom-marker'><img draggable='false'><span></span></div>");
        _marker.css('z-index', that.css('z-index') + 1);
        const __marker = _marker.find("img");
        const size = marker.size || options.marker_size;
        const draggable = typeof(marker.draggable) === 'undefined' ? true : marker.draggable;
        var offset = null;
        marker.size = size;
        __marker.attr('src', marker.src);
        // Marker content text
        if (typeof(marker.hint) != 'undefined') {
            const span = _marker.find("span");
            span.empty().append(marker.hint.value || "");
            span.css(marker.hint.style || {});
        }
        __marker.height(size);
        __marker.width(size);
        const markerObj = {
            id: markerId,
            marker: _marker,
            param: marker
        };
        params.markerId++;
        // Mark the click listener and add it after a period of delay to avoid repeated triggering of click events on the mobile terminal
        setTimeout(function() {
            _marker.click(function() {
                // This click event will also be triggered after the hammer drag is over, so configure offset=null here
                if (offset === null) {
                    if (typeof(marker.click) != "undefined") {
                        marker.click(markerObj);
                    }
                    that.trigger("zoom_marker_click", markerObj);
                }
                offset = null;
            });
        }, 100);
        // Floating listener
        if (typeof(marker.dialog) !== 'undefined') {
            _marker.mousemove(function(e) {
                if (offset === null) {
                    options.hover_marker_id = markerObj.id;
                    dialog.empty().append(marker.dialog.value || '').css(marker.dialog.style || {}).show().offset({
                        left: (marker.dialog.offsetX || 0) + e.pageX,
                        top: (marker.dialog.offsetY || 0) + e.pageY
                    });
                }
            });
            _marker.mouseout(function() {
                options.hover_marker_id = null;
                dialog.hide();
            });
        }
        that.parent().append(_marker);
        markerList.push(markerObj);
        params.markerList = markerList;
        setMarkerOffset(id, _marker, marker, that.offset());
        // Add drag listener
        if (draggable) {
            const picHammer = new Hammer(document.getElementById(_marker.attr('id')));
            picHammer.on("pan", function(e) {
                // Maximum and minimum width restrictions
                const minX = that.offset().left - marker.size / 2;
                const maxX = minX + that.width();
                const minY = that.offset().top - marker.size;
                const maxY = minY + that.height();
                var x = e.deltaX + offset.left;
                var y = e.deltaY + offset.top;
                if (x < minX) {
                    x = minX;
                } else if (x > maxX) {
                    x = maxX;
                }
                if (y < minY) {
                    y = minY;
                } else if (y > maxY) {
                    y = maxY;
                }
                _marker.offset({
                    left: x,
                    top: y
                });
            });
            picHammer.on("panstart", function() {
                offset = _marker.offset();
            });
            picHammer.on("panend", function() {
                // Configure offset=null in _marker.click(function()
                //offset = null;
                // Update the actual coordinates recorded by the marker
                const minX = that.offset().left - marker.size / 2;
                const minY = that.offset().top - marker.size;
                markerObj.param.x = (_marker.offset().left - minX) * options.imgNaturalSize.width / that.width();
                markerObj.param.y = (_marker.offset().top - minY) * options.imgNaturalSize.height / that.height();
                that.trigger("zoom_marker_move_end", {
                    x: markerObj.param.x,
                    y: markerObj.param.y,
                    markerObj: markerObj
                });
            });
        }

        return markerObj;
    };

    /**
     * Reload icon after dragging or zooming
     * @param id    the id corresponding to the item
     */
    const reloadMarkers = function(id) {
        const params = getGlobalParam(id);
        const that = params.that;
        const offset = that.offset();
        $(params.markerList).each(function(index, element) {
            setMarkerOffset(id, element.marker, element.param, offset);
        });
    };

    /**
     * Clear mark
     * @param id    the id corresponding to the item
     */
    const cleanMarkers = function(id) {
        const params = getGlobalParam(id);
        const markerList = params.markerList;
        $(markerList).each(function(index, element) {
            element.marker.unbind();
            element.marker.remove();
        });
        params.markerList = [];
        params.options.markers = [];
        params.dialog.hide();
    };

    /**
     * Delete mark
     * @param id        the id corresponding to the item
     * @param markerId  Unique ID of the marker
     */
    const removeMarker = function(id, markerId) {
        const params = getGlobalParam(id);
        const options = params.options;
        const dialog = params.dialog;
        $(params.markerList).each(function(index, element) {
            if (element.id === markerId) {
                element.marker.unbind();
                element.marker.remove();
                // If the current floating window is displayed on the marker, the floating window needs to be hidden
                if (((options.hover_marker_id || null) !== null) && options.hover_marker_id === markerId) {
                    dialog.hide();
                }
                return false;
            }
        });
    };

    /**
     * Configure marker offset
     * @param id            the id corresponding to the item
     * @param marker        The marker object that needs to be configured
     * @param position      The location information of the marker, including {x:, y:}
     * @param offset        Image offset information
     */
    const setMarkerOffset = function(id, marker, position, offset) {
        const params = getGlobalParam(id);
        const that = params.that;
        const options = params.options;
        marker.offset({
            left: that.width() * position.x / options.imgNaturalSize.width + offset.left - position.size / 2,
            top: that.height() * position.y / options.imgNaturalSize.height + offset.top - position.size
        });
    };

    /**
     * Autoriser ou non le glissement d'image
     * @param id            the id corresponding to the item
     * @param enable        Whether to allow dragging, boolean
     */
    const enableDrag = function(id, enable) {
        const params = getGlobalParam(id);
        params.options.enable_drag = enable;
    };

    /**
     * Move the image and corresponding mark to the top layer
     * @param id            Image id
     */
    const moveImageTop = function(id) {
        const params = getGlobalParam(id);
        // In addition to the current layer, other layers must restore the original z-index attribute
        GLOBAL.forEach(function(param, index) {
            if (param.id !== id) {
                param.that.css('z-index', param.index);
                param.that.addClass('zoom-marker-opacity');
                // The z-index of the marker set is configured as the current image level +1
                param.markerList.forEach(function(element, index) {
                    element.marker.css('z-index', param.index + 1);
                    element.marker.addClass('zoom-marker-opacity');
                });
                // canvas layer order
                if (param.canvas.item !== null) {
                    param.canvas.item.css('z-index', param.index + 1);
                    param.canvas.item.addClass('zoom-marker-opacity');
                }
            }
        });
        // Configure the current layer z-index
        if (typeof(params) !== 'undefined') {
            const markerList = params.markerList;
            const img = params.that;
            img.removeClass('zoom-marker-opacity');
            img.css('z-index', MAX_IMG_Z_INDEX);
            markerList.forEach(function(element, index) {
                element.marker.css('z-index', MAX_IMG_Z_INDEX+1);
                element.marker.removeClass('zoom-marker-opacity');
            });
            if (params.canvas.item !== null) {
                params.canvas.item.css('z-index', MAX_IMG_Z_INDEX + 1);
                params.canvas.item.removeClass('zoom-marker-opacity');
            }
        }
    };

    /**
     * If the currently configured layer is at the top, return true, otherwise return false
     * @param id
     * @return {boolean}
     */
    const isLayoutOnTop = function(id) {
        const params = getGlobalParam(id);
        var maxIndex = -1;
        GLOBAL.forEach(function(param, index) {
            if (param.that.css('z-index') > maxIndex) {
                maxIndex = param.that.css('z-index');
            }
        });
        // If the currently clicked layer level is the same as the maximum level, it indicates that the currently clicked layer is at the top level
        return params.that.css('z-index') === maxIndex;
    };

    /**
     * Add canvas drawing layer
     * @param id        The id of the image to be drawn
     */
    const addCanvas = function(id) {
        const pItem = $('#' + id + CANVAS_SUFFIX);
        if (pItem !== null) {
            pItem.remove();
        }
        const params = getGlobalParam(id);
        const options = params.options;
        const size = options.imgNaturalSize;
        const that = params.that;
        const item = $("<canvas id='" + id + CANVAS_SUFFIX + "' width='" + size.width + "' height='" +
            size.height + "'  style='z-index: " + (params.index + 1) + "; position: absolute; left: 100px; top: 0px; pointer-events:none'>" +
            "Current browser is not support canvas tag</canvas>");
        that.parent().append(item);
        const context = document.getElementById(id + CANVAS_SUFFIX).getContext("2d");
        params.canvas.item = item;
        params.canvas.context = context;
        resizeCanvas(id);
    };

    /**
     * Redraw the canvas layer, bind with the image ID
     * @param id        The image ID of the canvas that needs to be redrawn
     */
    const resizeCanvas = function(id) {
        const params = getGlobalParam(id);
        const item = params.canvas.item;
        if (item === null) {
            return;
        }
        const that = params.that;
        const offset = that.offset();
        // Adjust position
        item.offset({
            top: that.offset().top,
            left: that.offset().left
        });
        item.height(that.height());
        item.width(that.width());
    };

    /**
     * Image pre-scaling
     * @param img
     * @param targetWidth       Image pre-scaling
     * @param targetHeight      Image height after scaling
     * @param targetLeft        The left offset of the image after scaling
     * @param targetTop         Offset on the zoomed image
     * @return {{offset: {top: number, left: number, bottom: *, right: *}, isTerminate: boolean, isOverlap: boolean, width: number, height: number}}
     */
    const limitLockZoom = function(img, targetWidth, targetHeight, targetLeft, targetTop, center) {
        // Get parent container and image size
        const superOffset = img.parent().offset();
        const maxX = img.parent().width() + superOffset.left;
        const maxY = img.parent().height() + superOffset.top;
        const minX = superOffset.left;
        const minY = superOffset.top;
        const width = parseInt(img.width());
        const height = parseInt(img.height());
        const parentWidth = parseInt(img.parent().width());
        const parentHeight = parseInt(img.parent().height());
        var result = {
            'isTerminate': false, // Whether to terminate the zoom
            'isOverlap': false, // Is it out of bounds
            'height': 0, // Image width...
            'width': 0,
            'offset': {
                'left': targetLeft,
                'top': targetTop,
                'right': targetLeft + targetWidth,
                'bottom': targetTop + targetHeight
            }
        };
        // If it is an enlargement operation, it will return as long as the length of one side exceeds the limit, no need to enlarge
        if ((targetWidth > width) && (width >= parentWidth || height >= parentHeight)) {
            result.isTerminate = true;
            return result;
        }
        // The left border is out of bounds after zooming
        if (result.offset.left < minX) {
            result.isOverlap = true;
            result.offset.left = minX;
        }
        // Right border out of bounds after zooming
        if (result.offset.right > maxX) {
            result.isOverlap = true;
            result.offset.right = maxX;
        }
        // The upper boundary is out of bounds after zooming
        if (result.offset.top < minY) {
            result.isOverlap = true;
            result.offset.top = minY;
        }
        // The bottom border is out of bounds after zooming
        if (result.offset.bottom > maxY) {
            result.isOverlap = true;
            result.offset.bottom = maxY;
        }
        // deal with
        if (result.isOverlap) {
            result.width = result.offset.right - result.offset.left;
            result.height = result.offset.bottom - result.offset.top;
            if (result.width >= parentWidth) {
                result.height = height * result.width / width;
                result.offset.top = center.y - (center.y - img.offset().top) / height * targetHeight;
                if (result.offset.top < minY) {
                    result.offset.top = minY;
                } else if (result.offset.bottom > maxY) {
                    result.offset.top = maxY - targetHeight;
                }
            } else if (result.height >= parentHeight) {
                result.width = width * result.height / height;
                result.offset.left = center.x - (center.x - img.offset().left) / width * targetWidth;
                if (result.offset.left < minX) {
                    result.offset.left = minX;
                } else if (result.offset.right > maxX) {
                    result.offset.left = maxX - targetWidth;
                }
            }
        }
        return result;
    };

    const limitLockOffset = function(img, x, y) {
        // Get parent container and image size
        const superOffset = img.parent().offset();
        const maxX = img.parent().width() + superOffset.left;
        const maxY = img.parent().height() + superOffset.top;
        const width = img.width();
        const height = img.height();
        var offsetX = x;
        var offsetY = y;
        if ((offsetX + width) > maxX) {
            offsetX = maxX - width;
        } else if (offsetX < superOffset.left) {
            offsetX = superOffset.left;
        }
        if ((offsetY + height) > maxY) {
            offsetY = maxY - height;
        } else if (offsetY < superOffset.top) {
            offsetY = superOffset.top;
        }
        img.offset({
            top: offsetY,
            left: offsetX
        });
    };

    var defaults = {
        rate: 0.2, // Zoom rate of mouse scroll
        src: null, // Picture resource
        width: 500, // Specify the image width
        min: 300, // Minimum image width
        max: null, // Image width
        markers: [], // marker array, [{src:"marker.png", x:100, y:100, size:20, click:fn()}]
        marker_size: 24, // Default marker size
        enable_drag: false, // Whether to allow dragging, allowed by default
        auto_index_z: true, // Automatic configuration of image iteration order
        enable_canvas: false, // Whether to enable the canvas drawing layer, it will affect the performance
        zoom_lock: false, // Zoom lock, turn on the picture midpoint as the zoom midpoint
        move_limit: false, // Drag the lock, turn it on to only allow the image to be dragged inside the parent container
        // customisation by Gaïa KHOUAS 18/05/2021
        contactName: null,
        city: null,
        address: null, // address of the lab
        description: null,
        tel:null,
        name: null,
        email:null,
        news: null
    }

})(window.jQuery);